/// @file z80_emulator//Instruction_ROM.cpp

#include <z80_emulator/Instruction_ROM.h>
#include <z80_emulator/Data_bus_RAM.h>
#include <z80_emulator/emulator_errors.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <vector>

namespace z80_emulator
{

static const char* instruction_names[] = {
/*    0            1         2          3           4        5      6           7     8          9         A          B         C          D         E        F */
/* 0 */ "nop", "ld_SS_WORD" , "ld_vbc_a" , "inc_SS", "V_X", "V_X", "ld_X_BYTE", "rlca","ex_af_af_", "add_hl_SS", "ld_a_vbc", "dec_SS","V_X", "V_X","ld_X_BYTE", "rrca",
/* 1 */ "djnz_OFFSET", "ld_SS_WORD", "ld_vde_a", "inc_SS", "V_X", "V_X", "ld_X_BYTE", "rla","jr_OFFSET", "add_hl_SS", "ld_a_vde", "dec_SS","V_X", "V_X","ld_X_BYTE", "rra",
/* 2 */ "jr_Z_OFFSET", "ld_SS_WORD", "ld_vWORD_hl", "inc_SS", "V_X", "V_X", "ld_X_BYTE", "daa","jr_Z_OFFSET", "add_hl_SS", "ld_hl_vWORD", "dec_SS","V_X", "V_X","ld_X_BYTE", "cpl",
/* 3 */ "jr_Z_OFFSET", "ld_SS_WORD", "ld_vWORD_a", "inc_SS", "V_vhl", "V_vhl", "ld_vhl_BYTE", "scf","jr_Z_OFFSET", "add_hl_SS", "ld_a_vWORD", "dec_SS","V_X", "V_X","ld_X_BYTE", "ccf",
/* 4 */ "ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y", "ld_X_Y", "ld_X_Y", "ld_X_vhl", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_vhl", "ld_X_Y",
/* 5 */ "ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y", "ld_X_Y", "ld_X_Y", "ld_X_vhl", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_vhl", "ld_X_Y",
/* 6 */ "ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y", "ld_X_Y", "ld_X_Y", "ld_X_vhl", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_vhl", "ld_X_Y",
/* 7 */ "ld_vhl_Y", "ld_vhl_Y","ld_vhl_Y", "ld_vhl_Y", "ld_vhl_Y", "ld_vhl_Y", "halt", "ld_vhl_Y", "ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_Y", "ld_X_Y","ld_X_vhl", "ld_X_Y",
/* 8 */ "U_a_Y", "U_a_Y","U_a_Y", "U_a_Y", "U_a_Y", "U_a_Y", "U_a_vhl","U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_vhl", "U_a_Y",
/* 9 */ "U_a_Y", "U_a_Y","U_a_Y", "U_a_Y", "U_a_Y", "U_a_Y", "U_a_vhl","U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_vhl", "U_a_Y",
/* A */ "U_a_Y", "U_a_Y","U_a_Y", "U_a_Y", "U_a_Y", "U_a_Y", "U_a_vhl","U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_vhl", "U_a_Y",
/* B */ "U_a_Y", "U_a_Y","U_a_Y", "U_a_Y", "U_a_Y", "U_a_Y", "U_a_vhl","U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_Y", "U_a_Y","U_a_vhl", "U_a_Y",
/* C */ "ret_Z", "pop_TT","jp_Z_WORD", "jp_WORD", "call_Z_WORD", "push_TT", "U_a_BYTE", "rst_N","ret_Z", "ret","jp_Z_WORD", "CB","call_Z_WORD", "call_WORD", "U_a_BYTE", "rst_N",
/* D */ "ret_Z", "pop_TT","jp_Z_WORD", "out_vBYTE_a", "call_Z_WORD", "push_TT", "U_a_BYTE", "rst_N","ret_Z", "exx","jp_Z_WORD", "in_a_BYTE", "call_Z_WORD", "DD","U_a_BYTE", "rst_N",
/* E */ "ret_Z", "pop_TT","jp_Z_WORD", "ex_vsp_hl", "call_Z_WORD", "push_TT", "U_a_BYTE", "rst_N","ret_Z", "jp_hl","jp_Z_WORD", "ex_de_hl","call_Z_WORD", "ED","U_a_BYTE", "rst_N",
/* F */ "ret_Z", "pop_TT","jp_Z_WORD", "di", "call_Z_WORD", "push_TT", "U_a_BYTE", "rst_N","ret_Z", "ld_sp_hl","jp_Z_WORD", "ei","call_Z_WORD", "FD","U_a_BYTE", "rst_N"
};

uint8_t next_opcode=0;

uint8_t opcode_sizes[] = {
//         0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xA  0xB  0xC  0xD  0xE  0xF
//-----------------------------------------------------------------------------------------
/* 0x00 */ 0x1, 0x3, 0x1, 0x1, 0x1, 0x1, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x1,
/* 0x10 */ 0x2, 0x3, 0x1, 0x1, 0x1, 0x1, 0x2, 0x1, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x1,
/* 0x20 */ 0x1, 0x3, 0x3, 0x1, 0x1, 0x1, 0x2, 0x1, 0x2, 0x1, 0x3, 0x1, 0x1, 0x1, 0x2, 0x1,
/* 0x30 */ 0x1, 0x3, 0x3, 0x1, 0x1, 0x1, 0x2, 0x1, 0x2, 0x1, 0x3, 0x1, 0x1, 0x1, 0x2, 0x1,
/* 0x40 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0x50 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0x60 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0x70 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0x80 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0x90 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0xA0 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0xB0 */ 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
/* 0xC0 */ 0x1, 0x1, 0x3, 0x3, 0x3, 0x1, 0x2, 0x1, 0x1, 0x1, 0x3, 0x2, 0x3, 0x3, 0x2, 0x1,
/* 0xD0 */ 0x1, 0x1, 0x3, 0x2, 0x3, 0x1, 0x2, 0x1, 0x1, 0x1, 0x3, 0x2, 0x3, 0xF, 0x2, 0x1,
/* 0xE0 */ 0x1, 0x1, 0x3, 0x1, 0x3, 0x1, 0x2, 0x1, 0x1, 0x1, 0x3, 0x1, 0x3, 0xF, 0x2, 0x1,
/* 0xF0 */ 0x1, 0x1, 0x3, 0x1, 0x3, 0x1, 0x2, 0x1, 0x1, 0x1, 0x3, 0x1, 0x3, 0xF, 0x2, 0x1,
};

uint8_t opcode_sizes_ED[] = {
//         0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xA  0xB  0xC  0xD  0xE  0xF
//-----------------------------------------------------------------------------------------
/* 0x00 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
/* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0x30 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0x40 */ 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x2,
/* 0x50 */ 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x2,
/* 0x60 */ 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x2,
/* 0x70 */ 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x0, 0x2, 0x2, 0x2, 0x4, 0x2, 0x2, 0x2, 0x0,
/* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
/* 0x90 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0xA0 */ 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0,
/* 0xB0 */ 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0,
/* 0xC0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
/* 0xD0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0xE0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0xF0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

uint8_t opcode_sizes_I[] = {
//         0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xA  0xB  0xC  0xD  0xE  0xF
//-----------------------------------------------------------------------------------------
/* 0x00 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
/* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0x20 */ 0x0, 0x4, 0x4, 0x2, 0x2, 0x2, 0x3, 0x0, 0x0, 0x2, 0x4, 0x2, 0x2, 0x2, 0x3, 0x0,
/* 0x30 */ 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x4, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0x40 */ 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0,
/* 0x50 */ 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0,
/* 0x60 */ 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x2,
/* 0x70 */ 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0,
/* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 
/* 0x90 */ 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0,
/* 0xA0 */ 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0,
/* 0xB0 */ 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3, 0x0,
/* 0xC0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 
/* 0xD0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0xE0 */ 0x0, 0x2, 0x0, 0x2, 0x0, 0x2, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
/* 0xF0 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

void opcode_get_ind(uint8_t upper_nibble, register_id src, uint8_t& opcode)
{
    switch(src)
    {
        case register_a:
            opcode |= (upper_nibble << 0x4) | 0x2;
        default:
            break;
    }
}

void opcode_get_main(uint8_t dst_upper_bit, register_id dst, register_id src, uint8_t& opcode)
{
    if((register_hl_ind == src) && (register_hl_ind == dst))
    {
        opcode = 0;
    }
    if(register_b <= src && src <= register_a)
    {
        opcode |= (src - register_b) | dst_upper_bit;
    }
    else
    {
        opcode = 0;
    }
    opcode |= (((dst - register_b) / 2) << 0x4) + 0x40;
}

ld::ld(register_id dst, register_id src)
: m_opcode(0)
, m_immediate(0)
{
    switch(dst)
    {
        case register_bc_ind:
            opcode_get_ind(0x0, src, m_opcode);
            break;
        case register_de_ind:
            opcode_get_ind(0x1, src, m_opcode);
            break;
        case register_b:
        case register_d:
        case register_h:
        case register_hl_ind:
            opcode_get_main(0x0, dst, src, m_opcode);
            break;
        case register_c:
        case register_e:
        case register_l:
        case register_a:
            opcode_get_main(0x8, dst, src, m_opcode);
            break;
        default:
            break;
    }
}

ld::ld(register_id dst, uint16_t immediate)
: m_opcode(0)
, m_immediate(immediate)
{
    
}

ld::ld(uint16_t immediate, register_id src)
: m_opcode(0)
, m_immediate(immediate)
{
    
}

ld::~ld(){}

void ld::append_bytes(std::vector<uint8_t>& bytes)
{
    bytes.push_back(m_opcode);
    if(opcode_sizes[m_opcode] == 2)
    {
        bytes.push_back(m_immediate);
    }
    else if(opcode_sizes[m_opcode] == 3)
    {
        bytes.push_back(m_immediate & 0x00FF);
        bytes.push_back((m_immediate & 0xFF00) >> 0x8);
    }
}

struct Instruction_ROM::Impl
{
public:
    Data_bus_RAM m_instruction_data;
    uint16_t m_instruction_size;
    uint16_t m_opcode_instructions;
    
    Impl(uint16_t instruction_size)
    : m_instruction_data(instruction_size)
    , m_instruction_size(instruction_size)
    , m_opcode_instructions(0)
    {
    }

    virtual ~Impl(){}
    
    void parse_instruction_list(std::vector<uint16_t>& instruction_list)
    {
        uint16_t current_address = 0;
        while(current_address < m_instruction_size)
        {
            instruction_list.push_back(current_address);
            uint8_t opcode = m_instruction_data.get_data(current_address);
            switch(opcode)
            {
                case 0xDD:
                case 0xFD:
                    ++current_address;
                    current_address 
                        += opcode_sizes_I[m_instruction_data
                                            .get_data(current_address)];
                    break;
                case 0xED:
                    ++current_address;
                    current_address 
                        += opcode_sizes_ED[m_instruction_data
                                            .get_data(current_address)];
                    break;
                default:
                    current_address += opcode_sizes[opcode];
                    break;
            }
        }
    }
};

Instruction_ROM::Instruction_ROM(uint16_t instruction_size)
    :m_p_impl(new Impl(instruction_size))
{
}

Instruction_ROM::~Instruction_ROM()
{
    delete m_p_impl;
    m_p_impl = 0;
}

uint16_t Instruction_ROM::get_section_size() const
{
    return m_p_impl->m_instruction_size;
}

uint8_t Instruction_ROM::get_data(uint16_t address)
{
    uint8_t data = 0;
    if( (address < m_p_impl->m_instruction_size)
     && (address < m_p_impl->m_instruction_data.get_section_size()))
    {
        data = m_p_impl->m_instruction_data.get_data(address);
    }
    return data;
}

void Instruction_ROM::set_data(uint16_t, uint8_t)
{
    
}

void Instruction_ROM::parse_instruction_list(std::vector<uint16_t>& instruction_list)
{
    m_p_impl->parse_instruction_list(instruction_list);
}
    
Error Instruction_ROM::read_binary(const char* p_filename)
{
    Error return_error = s_c_error_none;
    uint8_t array [m_p_impl->m_instruction_data.get_section_size()];
    uint8_t* p_iterator = array;
    int32_t fd = open(p_filename, O_RDONLY);
    uint8_t continue_reading = true;
    memset(array, 0, sizeof(array));
    uint16_t total_read_bytes = 0;
    while(continue_reading == true)
    {
        ssize_t read_bytes = read(fd, p_iterator, sizeof(array));
        printf("Read %ld bytes\n", read_bytes);
        if(read_bytes <= 0)
        {
            continue_reading = false;
        }
        total_read_bytes += read_bytes;
        p_iterator += read_bytes;
        if(total_read_bytes > sizeof(array))
        {
            return_error = s_c_error_too_large_instruction_size;
        }
    }
    close(fd);
    if(return_error == s_c_error_none)
    {
        for(uint16_t i = 0; i < total_read_bytes; i++)
        {
            m_p_impl->m_instruction_data.set_data(i, array[i]);
        }
    }
    return return_error;
}

void Instruction_ROM::add_instruction(instruction& instruction){}

}
